/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Event payload sent back to JS when a user interacts with an element. */
export interface EventPayload {
  /** Numeric element ID (matches the ID assigned in JS via createElement). */
  elementId: number
  /**
   * Event type string — matches the key used in EVENT_PROPS on the JS side.
   * e.g. "click", "mouseDown", "mouseEnter", "keyDown", "scroll", etc.
   */
  eventType: string
  /** Mouse X position in window coordinates (pixels). */
  x?: number
  /** Mouse Y position in window coordinates (pixels). */
  y?: number
  /**
   * Which mouse button: 0=left, 1=middle, 2=right.
   * Populated for: mouseDown, mouseUp, click, mouseDownOutside, contextMenu.
   */
  button?: number
  /**
   * Number of consecutive clicks (1=single, 2=double, 3=triple).
   * Populated for: mouseDown, mouseUp, click.
   */
  clickCount?: number
  /**
   * Whether this is a right-click (convenience for click events).
   * true when button==2 or ClickEvent::is_right_click().
   */
  isRightClick?: boolean
  /**
   * Which mouse button is currently held during a mouseMove.
   * Same encoding as `button`: 0=left, 1=middle, 2=right.
   * Populated for: mouseMove.
   */
  pressedButton?: number
  /**
   * Key name, e.g. "a", "enter", "escape", "down", "left", "f1".
   * Populated for: keyDown, keyUp.
   */
  key?: string
  /**
   * The character produced by the key press (e.g. "ß" for option-s).
   * May differ from `key` when modifiers are active.
   * Populated for: keyDown, keyUp.
   */
  keyChar?: string
  /**
   * Whether this is a key-repeat event (key held down).
   * Populated for: keyDown.
   */
  isHeld?: boolean
  /**
   * Scroll delta on the X axis (pixels or lines, see `precise`).
   * Populated for: scroll.
   */
  deltaX?: number
  /**
   * Scroll delta on the Y axis (pixels or lines, see `precise`).
   * Populated for: scroll.
   */
  deltaY?: number
  /**
   * true = pixel-precise (trackpad), false = line-based (mouse wheel).
   * Populated for: scroll.
   */
  precise?: boolean
  /**
   * Touch phase for scroll: "started", "moved", "ended".
   * Populated for: scroll (trackpad gestures).
   */
  touchPhase?: string
  /**
   * true = mouse entered element, false = mouse left element.
   * Populated for: mouseEnter, mouseLeave.
   */
  hovered?: boolean
  modifiers?: EventModifiers
}
export interface EventModifiers {
  shift: boolean
  ctrl: boolean
  alt: boolean
  cmd: boolean
}
export interface WindowSize {
  width: number
  height: number
}
export interface WindowOptions {
  title?: string
  width?: number
  height?: number
  minWidth?: number
  minHeight?: number
  resizable?: boolean
  fullscreen?: boolean
  transparent?: boolean
}
/** The main GPUI renderer exposed to Node.js. */
export declare class GpuixRenderer {
  constructor(eventCallback?: (err: Error | null, arg: EventPayload) => any | undefined | null)
  /** Initialize the GPUI application with a non-blocking NodePlatform. */
  init(options?: WindowOptions | undefined | null): void
  createElement(id: number, elementType: string): void
  /**
   * Destroy an element and all descendants. Returns array of destroyed IDs
   * so JS can clean up event handlers for the entire subtree.
   */
  destroyElement(id: number): Array<number>
  appendChild(parentId: number, childId: number): void
  removeChild(parentId: number, childId: number): void
  insertBefore(parentId: number, childId: number, beforeId: number): void
  setStyle(id: number, styleJson: string): void
  setText(id: number, content: string): void
  setEventListener(id: number, eventType: string, hasHandler: boolean): void
  /** Set the root element (called from appendChildToContainer). */
  setRoot(id: number): void
  /**
   * Set a custom prop on an element (for non-div/text elements like input, editor, diff).
   * Key is the prop name, value is JSON-encoded.
   */
  setCustomProp(id: number, key: string, valueJson: string): void
  /** Get a custom prop value from an element. Returns JSON string or null. */
  getCustomProp(id: number, key: string): string | null
  /** Signal that a batch of mutations is complete. Triggers re-render. */
  commitMutations(): void
  tick(): void
  isInitialized(): boolean
  getWindowSize(): WindowSize
  setWindowTitle(title: string): void
  focusElement(elementId: number): void
  blur(): void
}
/**
 * GPU-backed GPUI test renderer. Uses VisualTestAppContext (real Metal
 * rendering on macOS) with TestDispatcher for deterministic scheduling.
 * Same GpuixView and rendering pipeline as production.
 *
 * Usage from JS:
 *   const r = new TestGpuixRenderer()
 *   r.createElement(1, "div")
 *   r.setRoot(1)
 *   r.commitMutations()
 *   r.flush()                  // triggers GpuixView::render() via Metal
 *   r.simulateClick(50, 50)    // dispatches through GPUI hit testing
 *   const events = r.drainEvents()
 *   r.captureScreenshot("/tmp/test.png")  // saves rendered UI as PNG
 */
export declare class TestGpuixRenderer {
  constructor()
  createElement(id: number, elementType: string): void
  /**
   * Destroy an element and all descendants. Returns destroyed IDs
   * so JS can clean up event handlers.
   */
  destroyElement(id: number): Array<number>
  appendChild(parentId: number, childId: number): void
  removeChild(parentId: number, childId: number): void
  insertBefore(parentId: number, childId: number, beforeId: number): void
  setStyle(id: number, styleJson: string): void
  setText(id: number, content: string): void
  setEventListener(id: number, eventType: string, hasHandler: boolean): void
  /** Set the root element (called from appendChildToContainer). */
  setRoot(id: number): void
  /** Set a custom prop on an element (for non-div/text elements like input, editor, diff). */
  setCustomProp(id: number, key: string, valueJson: string): void
  /** Get a custom prop value from an element. */
  getCustomProp(id: number, key: string): string | null
  /**
   * Signal that a batch of mutations is complete.
   * In tests, this is a no-op — flush() handles the actual re-render.
   */
  commitMutations(): void
  /**
   * Notify the view entity and run GPUI until parked.
   * This triggers GpuixView::render() → build_element() → GPUI layout.
   * Must be called after mutations and before simulating events (GPUI's
   * hit testing requires elements to be laid out).
   */
  flush(): void
  /**
   * Simulate a click at the given window coordinates.
   * Dispatches MouseDown + MouseUp through GPUI's input pipeline,
   * which triggers the same event handlers as production.
   * IMPORTANT: Call flush() before this — hit testing requires laid-out elements.
   */
  simulateClick(x: number, y: number): void
  /**
   * Simulate key strokes through GPUI's input pipeline.
   * Format: space-separated keys, e.g. "a", "enter", "cmd-shift-p".
   * The focused element receives keyDown/keyUp events.
   */
  simulateKeystrokes(keystrokes: string): void
  /**
   * Simulate a single key down event through GPUI's input pipeline.
   * Format: modifier-key string, e.g. "a", "enter", "cmd-s".
   * Unlike simulate_keystrokes, this dispatches ONLY a KeyDownEvent —
   * no automatic KeyUpEvent follows. Use with simulate_key_up for
   * fine-grained key event testing.
   */
  simulateKeyDown(keystroke: string, isHeld?: boolean | undefined | null): void
  /**
   * Simulate a single key up event through GPUI's input pipeline.
   * Format: modifier-key string, e.g. "a", "enter", "cmd-s".
   * Pairs with simulate_key_down for fine-grained key event testing.
   */
  simulateKeyUp(keystroke: string): void
  /**
   * Simulate a mouse move to the given coordinates.
   * pressed_button: optional mouse button held during move (0=left, 1=middle, 2=right).
   * Used to simulate drag events.
   */
  simulateMouseMove(x: number, y: number, pressedButton?: number | undefined | null): void
  /**
   * Focus an element by its numeric ID.
   * The element must have a FocusHandle (created by sync_focus_handles when
   * the element has keyDown, keyUp, focus, or blur listeners).
   * Call flush() before this so the element tree and focus handles exist.
   */
  focusElement(id: number): void
  /**
   * Simulate a mouse down event at the given window coordinates.
   * Button: 0=left, 1=middle, 2=right. Defaults to left (0).
   */
  simulateMouseDown(x: number, y: number, button?: number | undefined | null): void
  /**
   * Simulate a mouse up event at the given window coordinates.
   * Button: 0=left, 1=middle, 2=right. Defaults to left (0).
   */
  simulateMouseUp(x: number, y: number, button?: number | undefined | null): void
  /**
   * Simulate a scroll wheel event at the given position.
   * delta_x and delta_y are in pixels (negative = scroll up/left).
   */
  simulateScrollWheel(x: number, y: number, deltaX: number, deltaY: number): void
  /**
   * Capture a screenshot of the current rendered state and save as PNG.
   * macOS only — requires Metal GPU rendering via VisualTestAppContext.
   */
  captureScreenshot(path: string): void
  /**
   * Return and clear all collected events since the last drain.
   * Events are collected synchronously — no event loop queuing.
   */
  drainEvents(): Array<EventPayload>
  /** Get all text content in the tree (depth-first order). */
  getAllText(): Array<string>
  /** Find element IDs matching the given type (e.g. "div", "text"). */
  findByType(elementType: string): Array<number>
  /** Check if an element has a specific event listener. */
  hasEventListener(id: number, eventType: string): boolean
  /** Get the text content of an element. */
  getText(id: number): string | null
  /** Get the full tree as JSON for snapshot testing. */
  getTreeJson(): string
}
